SEC [1],  Logsurfer  [2]  and  Swatch  [3]  are  three  typical  ex-amples of a rule-based log analysis tool



Mining  program  invariants  is  a  very importantstep  in our approach. There are some research efforts related to this  subject. Ernst et  al.developedDaikon [10] to  dis-cover program invariantsfor supporting program evolu-tion.Daikon  can dynamicallydiscover  invariants  at specific  source  code  points  by  checkingthe  values  of all program variablesin the scope. Jiang et al.proposedasearchalgorithm  to  infer  likely  invariants  in  distri-buted systems[12]. Rather thansearching the invariants of program variables, theiralgorithmsearchesinvariantpair-wisecorrelationsbetween two flow intensities, such  as  traffic  volume  and  CPU usage  thatare  moni-tored in distributed systems.They alsoproposedan EM algorithm in [11], and extendedtheir work to minecor-relationsamong  multiple  flow  intensities.In  contrast withthese methods, we  mineinvariantrelationshipsamong  the  counts  of  log  message  types,which present the characteristics  ofthe program  execution  flow. In addition, we  focus on sparse and integer invariants that can revealthe  essential relations  of  the system execu-tion  logic andare easilyunderstood  by  human  opera-tors.


Each equation corresponds to a specific invariant ofthe program executionflow, and the validity of such invariants is  notaffected by the  dynamics of the work-loads,the difference  ofsystem inputsor  the  interleav-ing  of  multiple  instances. In  this  paper,  we  call  them execution flow invariants


There are mainly two reasons that  we  look  atlinearinvariants amongthe  countsof differenttype  oflog  messages. 
	First,  linear  invariants encodemeaningful characteristics  ofsystem  execution paths.  They  universally  exist  in  many  standalone  or distributed  systems.
	Second,  an  anomaly  often  mani-fests  a  different  execution  path  from  the  normal  ones.

Therefore,  a  violation  of  such relations(invariants)means  a  program  executionanomaly. Because  log  se-quences  record  the  underlying execution  flowof the system  components,  we  believe  there  are  many  such linear equations,   i.e.   invariants,among   the   log   se-quences. If we can automatically discoverall such inva-riants  from the  collected historical  log  data,  we  can facilitate many system management tasks. example
	By  checking  whether  a  log  sequence  violates theinvariants,   we   can   detect   system problems.   As mentioned above,  a  violation  of  an  invariant  often means an anomaly in the programâ€Ÿs execution
	
	Each  invariant  contains  a  constraint  or an attribute of a system componentâ€Ÿsexecution flow. Based on the related execution flow properties of the broken invariants,  system  operators  can  find  the  potential causes offailure.

	Theinvariants  can  help  system  operators  to  better understand the structureand behavior of a system.


If  the  dimension  of  the  invariant  space  is ğ‘Ÿ,  there  existsat  most ğ‘Ÿdifferent  invariants satisfyingthat eachof them cannot be a linear combination of the others.

Furthermore,the  number  of  log  message typesin  each  message  groupis  usually  much  smaller than  the  total  number  of  log message  types. If  we  can divideall log  messages into differentgroups  properly and  mine  the  invariants  on  different  kinds  of  groups respectively,  the  search  space  of  the  algorithm  can  be largely  reduced.There aresome  systems  in  which  log messages do  notcontainsuch  parameters.  Just  as  prior work [5], our approach doesnot target these systems.

Even with the grouping strategy, the computational cost of invariant searching is still quite large. We try to fur-ther reduce the computational cost by introducing early termination  and pruningstrategies  which  will  be  dis-cussed in Section 6.3.




Log parsing. In most systems, log messages are usuallyunstructured  free-form  text  messages, and are difficult to be directly processed by a computer.In the log pars-ing  step,  we  convert  a  log  message  froman unstruc-tured text stringto a tuple-form representation that con-sists ofatimestamp, a messagesignature(i.e. a constant free  form  text  string  to  represent  a  log message  type),and a list of message parameter values.


Log message groupingand counting.Once parameter values  and  log  message  signatures  are separatedfrom all   log   messages,   we   first   automatically   discover whether  a  set  of  parameters  correspond  to  the  same program  variable.  Then, we group log  messages that contain  the samevalue  of  the  same  program  variabletogether. For example, the  log  messages containingthe same request  IDvalueare  grouped  together.  As  men-tioned  above, dividing log  messages into  someclose inner-related  groups  can  largely  reduce  the  computa-tional cost. For each message group, we count the num-ber  of log  messages  for  each  message  typeto obtain  a message count vectorfor further processing.


Invariant  mining. Next,  we  try  to  find  a  compact sparse integer invariant set for each typeof the log message groups. Message groups extracted accordingto the same program variable areconsidered asthe same typeof group. For example, the group of log messages with request  ID  #1#  and  the  group  of  log  messages  with  re-quest  ID  #2#  are  the  same typeof  message  groups. In this  paper,  we  combine  a  brute  force  searching  algo-rithm  and  a greedysearching  algorithm  to  make  the searching process tractable. 


Anomaly detection. We apply the obtained set of inva-riantsto detect anomalies.  A log sequence that violates an invariant is labeled as an anomaly


In  this  paper,  we  use  the algorithm thatwe  have  previously published [14]  to extractmessagesignaturesand  parameter  values  from log  messages. It  can  achieve  an  accuracy  of  more  than 95%[14].Becausethe log parser is not the focus of this paper, we do not discuss the detailsof the algorithm.


After  message signatureand parametervalueextraction, each log message ğ‘šwith itstime  stamp ğ‘‡(ğ‘š)can  be  represented  by  a  tuple ğ‘‡ğ‘š,ğ¾ğ‘š,ğ‘ƒğ‘‰ğ‘š,1,ğ‘ƒğ‘‰ğ‘š,2,...,ğ‘ƒğ‘‰ğ‘š,ğ‘ƒğ‘ğ‘š,we call  such  tuples  the tuple-form  representationsof  the log messages







INVARIANT MINING

		We collect thelog message groups corresponding to the same program variabletogetherand  discover their invariants  as  de-scribed  in Algorithm2.

		At  first, for each log  message group, we  count  the  number of log  messages for  each log  messagetype in  the  message  group to  obtain one message count vector. 

		For all log messages groups that are related to the same program variable, we can extract a set of message count vectors.

		The message count vec-tors that correspond to the same program variableform the  count  matrix ğ‘¿(Eq.4). 

		Then,  we need  to  identify the  invariant  space  and  the  row  space  of Xby  using singular  value decomposition and  analysis.

		Next,  we find  the  sparse  invariant  vectors in  the  invariant  space.

			To  find  a  sparse  invariant  vector  with ğ‘˜non-zero coef-ficientswith a small valueof ğ‘˜(e.g, <5in most cases),we can use a brute  force search algorithm to obtain the optimal  solution.  However,  when kis  large, the brute force algorithm has to search in a huge searching space. In this case, we use a greedy algorithm[19]to obtain an invariant candidate.

			Finally, we validate the found invariants using the collected historical logs.


	Estimate the invariant space
		Once  we have constructedthe  matrix ğ‘¿fromthe  col-lectedhistorical  logs,  we  can estimatethe  invariant spaceby singularvalue decomposition(SVD)opera-tion.

		Instead of the energy ratio, we use the support ratio as a criterionto  determine  the  invariant  space(and, at  the sametime,  the  row  space). It  can  directly  measure  the matching  degree  between  the  collected  logs  and  the invariants. 

		For an invariant, the support ratio is defined as the percentageof the log message groupsthat do not breakthe  invariant.			